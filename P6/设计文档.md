## 整体器件

![alt text](image-1.png)

![alt text](image.png)

## 关键模块定义

### F级
#### PC(程序计数器)
**端口说明**

| 信号名       | 方向 | 功能描述 |
|-----------| ---- |------|
| Clk       | I | 时钟信号 |
| Reset     | I | 同步复位，Reset有效，寄存器置初值为0x00003000 |
| NPC[31:0] | I | 32位输入 |
| PC_en     | I | 值为1时NPC写入PC，值为0时不写入，用于阻塞 |
| PC[31:0]  | O | 32位输出 |

#### NPC(下指令地址)
**端口说明**

| 信号名         | 方向 | 描述                                       |
|-------------| --- |------------------------------------------|
| F_PC[31:0]    | I | 当前指令的地址                                  |
| imm16[15:0] | I | 16位偏移                                    |
| imm26[25:0]  | I | 26位偏移                                    |
| GRF[31:0]   | I | 绝对跳转地址                                   |
| NPCsle[2:0] | I | 000:顺序执行 001：跳转26位立即数 010：跳转GRF 011:beq跳转指令 |
| zero        | I | 1:rs = rt 0:re != rt                     |
| signal      | I | 预留控制信号 |
| NPC[31:0]   | O | 下一条指令的地址                                 |


#### IM(指令存储器)
**端口说明**

| 信号名          | 方向 | 功能描述 |
|--------------| --- | ---- |
| adress[31:0] | I | 存储器地址(数组下标) |
| Instr[31:0]  | O | 输出指令 |

### F级到D级寄存器
#### FDreg
**端口说明**

| 信号名 | 方向 | 功能描述 |
|--------| --- | -------- |
| clk | I | 时钟信号 |
| reset | I | 复位信号 |
| FD_en | I | FDreg写使能信号(阻塞时为0，无法从F级写入D级) |
| FD_clr | I | FDreg清0信号 |
| F_instr[31:0] | I | F级指令码 |
| F_PCplus8[31:0] | I | F级地址加8 |
| F_PC[31:0] | I | F级指令地址 |
| D_instr[31:0] | O | D级指令码 |
| D_PCplus8[31:0] | O | D级地址加8 |
| D_PC[31:0] | O | D级指令地址 |

### D级
#### D_control(D级控制器)
**端口说明**

| 信号名 | 方向 | 功能描述 |
| ------| ---- | -------- |
| fuc[5:0]     | I | 决定指令类型         |
| op[5:0]      | I | 决定指令类型         |
| NPCSle[2:0]  | O | 选择跳转指令         |
| exstyle[1:0] | O | 拓展类型           |
| RegDst[1:0] | O | 选择GRF A3的输入    |
| t_rs[3:0]    | O | D级指令rs寄存器Tuse值 |
| t_rt[3:0]    | O | D级指令rt寄存器Tuse值 |
| t[3:0]       | O | D级指令的Tnew值 |


#### GRF
##### (D级只用到GRF的读出功能)
**端口说明**
| 信号名 | 方向 | 功能描述 |
| ------| ---- | -------- |
| clk | I |时钟信号 | 
| reset | I | 复位信号 |
| A1[4:0] | I | 5位地址输入信号，指定32个寄存器中的一个数据读出到RD1 |
| A2[4:0] | I | 5位地址输入信号，指定32个寄存器中的一个数据读出到RD2 |
| RD1[31:0] | O | 输出A1指定的寄存器中的32位数据 |
| RD2[31:0] | O | 输出A2指定的寄存器中的32位数据 |

#### EXT(拓展单元)
**端口说明**

| 信号名称      | 方向 | 功能描述                    |
|-----------| ------- |-------------------------|
| imm[15:0] | I | 16位待扩展数                 |
| Exstyle | I | 00:符号扩展，01:0扩展，10:拓展到高位 |

#### CMP(比较器)
**端口说明**

| 信号名 | 方向 | 功能描述 |
| ------| ---- | -------- |
| inputA[31:0] | I | 31位输入(输入为转发后的修正值) |
| inputB[31:0] | I | 31位输入(输入为转发后的修正值) |
| signal | O | 预留控制信号 |
| zero | O | 1:两个数相等，跳转 0:两个数不相等，不跳转|

### D级到E级寄存器
#### DEreg
**端口说明**

| 信号名 | 方向 | 功能描述 |
| ------| ---- | -------- |
| clk | I | 时钟信号 |
| reset | I | 复位信号 |
| DE_en | I | DEreg写使能信号,始终为1 |
| DE_clr | I | DEreg清0信号(阻塞时为1，清除DEreg中值) |
| D_instr[31:0] | I | D级指令码 |
| D_PCplus8[31:0] | I | D级地址加8 |
| D_PC[31:0] | I | D级指令地址 |
| D_RD1[31:0] | I | D级GRF输出1 |
| D_RD2[31:0] | I | D级GRF输出2 |
| D_A3[4:0] | I | D级指令对应的GRF_A3值(GRF写入地址) |
| D_ext32[31:0] | I | D级拓展器拓展输出值 |
| E_instr[31:0] | O | E级指令码 |
| E_PCplus8[31:0] | O | E级地址加8 |
| E_PC[31:0] | O | E级指令地址 |
| E_RD1[31:0] | O | E级指令GRF输出1 |
| E_RD2[31:0] | O | E级指令GRF输出2 |
| E_A3[4:0] | O | E级指令对应的GRF_A3值(GRF写入地址) |
| E_ext32[31:0] | O | E级立即数拓展值 |

### E级
#### E_control(E级控制器)
**端口说明**

| 信号名 | 方向 | 功能描述 |
| ------| ---- | -------- |
| fuc[5:0]     | I | 决定指令类型         |
| op[5:0]      | I | 决定指令类型         |
| ALUOp[2:0]   | O | ALU执行指令        |
| Extsle       | O | 是否拓展           |
| t_rs[3:0]    | O | E级指令rs寄存器Tuse值 |
| t_rt[3:0]    | O | E级指令rt寄存器Tuse值 |
| t[3:0]       | O | E级指令的Tnew值 |

#### ALU (算数逻辑单元)
**端口说明**

| 信号名称 | 方向 | 功能描述                                      |
| --------- | ------- |-------------------------------------------|
| A[31:0] | I | 32位输入运算数A  00：add,01:sub,10:or,11:compare |
| B[31:0] | I | 32位输入运算数B                                 |
| res[31:0] | O | 32位运算输出结果                                 |
| ALUOp[1:0] | I | 控制信号                                      |

### E级到M级寄存器
#### EMreg
**端口说明**

| 信号名 | 方向 | 功能描述 |
| ------| ---- | -------- |
| clk | I | 时钟信号 |
| reset | I | 复位信号 |
| EM_en | I | EMreg写使能信号,始终为1 |
| EM_clr | I | EMreg清0信号,始终为0 |
| E_instr[31:0] | I | E级指令地址 |
| E_PCplus8[31:0] | I | E级地址加8 |
| E_PC[31:0] | I | E级指令地址 |
| E_ALUres[31:0] | I | E级指令计算结果 |
| E_RD2[31:0] | I | E级指令GRF输出2 |
| E_A3[4:0] | I | E级指令对应的GRF_A3值(GRF写入地址) |
| M_instr[31:0] | O | M级指令地址 |
| M_PCplus8[31:0] | O | M级地址加8 |
| M_PC[31:0] | O | M级指令地址 |
| M_ALUres[31:0] | O | M级指令计算结果 |
| M_RD2[31:0] | O | M级指令GRF输出2 |
| M_A3[4:0] | O | M级指令对应的GRF_A3值(GRF写入地址) |

### M级
#### M_control(M级控制器)
**端口说明**

| 信号名 | 方向 | 功能描述 |
| ------| ---- | -------- |
| fuc[5:0]     | I | 决定指令类型         |
| op[5:0]      | I | 决定指令类型         |
| MemWrite     | O | DM的写使能端        | 
| t_rs[3:0]    | O | E级指令rs寄存器Tuse值 |
| t_rt[3:0]    | O | E级指令rt寄存器Tuse值 |
| t[3:0]       | O | E级指令的Tnew值 |

#### DM
**端口说明**

| 信号名       | 方向 | 描述      |
|-----------| --- |---------|
| WD[31:0]  | I | 写入的数据   |
| addr[31:0] | I | 要操作的内存地址 |
| WE       | I | 写使能 1:WD可以被写入 0:无法写入 |
| Clk       | I | 时钟,只影响写入，不影响读出 |
| reset     | I | 异步复位信号  |
| WPC[31:0] | I | 存入数据时指令地址 |
| D[31:0]   | O | 回写数据 |

### M级到W级
#### MWreg
**端口说明**

| 信号名 | 方向 | 功能描述 |
| ------| ---- | -------- |
| clk | I | 时钟信号 |
| reset | I | 复位信号 |
| MW_en | I | DEreg写使能信号,始终为1 |
| MW_clr | I | FD寄存器清0信号,始终为0 |
| M_instr[31:0] | I | M级指令地址 |
| M_PCplus8[31:0] | I | M级地址加8 |
| M_PC[31:0] | I | M级指令地址 |
| M_ALUres[31:0] | I | M级指令计算结果 |
| M_RD2[31:0] | I | M级指令GRF输出2 |
| M_A3[4:0] | I | M级指令对应的GRF_A3值(GRF写入地址) |
| M_data[31:0] | I | M级DM读出的回写数据 |
| W_instr[31:0] | O | W级指令地址 |
| W_PCplus8[31:0] | O | W级地址加8 |
| W_PC[31:0] | O | W级指令地址 |
| W_A3[4:0] | O | W级指令对应的GRF_A3值(GRF写入地址) |
| W_ALUres[31:0] | O | W级指令计算结果 |
| W_data[31:0] | O | W级DM读出的回写数据 |

### W级
#### W_control(W级控制器)
**端口说明**

| 信号名 | 方向 | 功能描述 |
| ------| ---- | -------- |
| fuc[5:0]     | I | 决定指令类型         |
| op[5:0]      | I | 决定指令类型         |
| MemData[1:0] | O | 选择GRF WD的输入    |
| Regwrite     | O | GRF写使能端        |
| t_rs[3:0]    | O | W级指令rs寄存器Tuse值 |
| t_rt[3:0]    | O | W级指令rt寄存器Tuse值 |
| t[3:0]       | O | W级指令的Tnew值 |

#### GRF(寄存器堆)
**端口说明** 
| 信号名称 | 方向 | 功能描述 |
| --------- | ------- | ----------------|
| clk | I | 时钟信号 |
| reset | I | 同步复位信号，将32个寄存器的值清0. 1：复位 0：无效 |
| WE | I |写能信号 1：可以写入 0:不能写入 |
| A3[4:0] | I | 5位地址输入信号，指定32个寄存器中的一个作为写入的寄存器 |
| WD[31:0] | I | 32位的数据输入信号 |

## 说明
#### 一、控制信号说明
|          | add    | sub    | ori    | lui    | lw     | sw     | beq    | j      | jr     | jal    |
|----------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------| 
| op       | 000000 | 000000 | 001101 | 001111 | 100011 | 101011 | 000100 | 000010 | 000000 | 000011 |
| fuc      | 100000 | 100010 | xxxxxx | xxxxxx | xxxxxx | xxxxxx | xxxxxx | xxxxxx | 001000 | xxxxxx |
| RegWrite | 1      | 1      | 1      | 1      | 1      | 0      | 0      | 0      | 0      | 1      |
| ALUOp    | 00     | 01     | 10     | 00     | xx     | xx     | xx     | xx     | xx     | xx     |
| RegDst   | 01     | 01     | 00     | 00     | 00     | 00     | 00     | xx     | xx     | 10     |
| NPCsle   | 000    | 000    | 000    | 000    | 000    | 000    | 011    | 001    | 010    | 001    |
| Extsle   | 0      | 0      | 1      | 1      | 1      | 1      | x      | x      | x      | x      |
| exstyle  | 00     | 00     | 01     | 10     | 00     | 00     | 00     | 00     | 00     | 00     |
| MemData  | 00     | 00     | 00     | 00     | 01     | 00     | 00     | 00     | 00     | 10     |
| MemWrite | 0      | 0      | 0      | 0      | 0      | 1      | 0      | 0      | 0      | 0      |

#### 二、转发说明
###### **5个转发终点:**
###### CMP(inputA,inputB),GRF(rd1,rd2),DM(wd) 
###### (NPC(GRF)本质是GRF输出)
###### **4个转发起点:**
###### E_PCplus8,M_ALUres,W_dm_wd,M_ALUres,M_PCplus8
###### **15条转发通路:**
**1.(M_ALUres):**
D_RD1/RD2_from_M 
E_RD1/RD2_from_M
**2.(W_dm_wd):**
D_RD1/RD2_from_W
D_RD1/RD2_from_W
M_RD2_from_W
**3.(E_PCplus8):**
D_RD1/RD2_from_E_PCplus8
**4.(M_PCplus8):**
D_RD1/RD2_from_M_PCplus8
E_RD1/RD2_from_M_PCplus8

##### **转发判断条件：**
1. 是否为 isPCplus8
2. 寄存器编号是否为 0
3. 转发起点和终点寄存器是否相同
4. t_use 值是否存在
5. t_new 值是否存在
6. t_use 是否大于等于 t_new


#### 三、阻塞说明
##### **阻塞判断条件：**
1. 寄存器编号是否为 0
2. 转发起点和终点寄存器是否相同
3. t_use 值是否存在
4. t_new 值是否存在
5. t_use 是否小于 t_new
```
assign D_stall = (E_A3 != 5'b00000 && D_rs == E_A3 && D_t_rsuse != 4'd15 && E_t_new != 4'd15 && D_t_rsuse < E_t_new) ? 1'b1 :
                 (E_A3 != 5'b00000 && D_rt == E_A3 && D_t_rtuse != 4'd15 && E_t_new != 4'd15 && D_t_rtuse < E_t_new) ? 1'b1 :
                 (M_A3 != 5'b00000 && D_rs == M_A3 && D_t_rsuse != 4'd15 && M_t_new != 4'd15 && D_t_rsuse < M_t_new) ? 1'b1 :
                 (M_A3 != 5'b00000 && D_rt == M_A3 && D_t_rtuse != 4'd15 && M_t_new != 4'd15 && D_t_rtuse < M_t_new) ? 1'b1 :
                 (W_A3 != 5'b00000 && D_rs == W_A3 && D_t_rsuse != 4'd15 && W_t_new != 4'd15 && D_t_rsuse < W_t_new) ? 1'b1 :
                 (W_A3 != 5'b00000 && D_rt == W_A3 && D_t_rtuse != 4'd15 && W_t_new != 4'd15 && D_t_rtuse < W_t_new) ? 1'b1 : 1'b0;
```

| 指令 | add | sub | lui | ori | lw | sw | beq | j | jal | jr |
| -- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | 
| t_rsuse | 1 | 1 | 1 | 1 | 1 | 1 | 0 | x | x | 0 |
| t_rtuse | 1 | 1 | x | x | x | 2 | 0 | x | x | x |
| t_new(D级) | 2 | 2 | 2 | 2 | 3 | x | x | x | 0 | x |
## 思考题
1. 提前分支判断依赖在分支指令的早期阶段（如译码 ID 阶段）就确定分支结果，但如果分支判断的条件（如寄存器值）还未完成计算（存在数据冒险），此时提前判断会得到错误结果，后续需要 “冲刷流水线” 修正错误，反而增加额外开销。
```
add $t0, $t1, $t2   
beq $t0, $0, label  
sub $t3, $t4, $t5  
label:
```
2. 在 MIPS 流水线中：
jal指令本身占 1 个地址（设为PC_jal）,延迟槽指令是紧随其后的下一条指令（地址为PC_jal+4）,且延迟槽指令一定会被执行；函数执行完成后，需要返回的地址是 “延迟槽指令之后的第一条指令地址”，即PC_jal+8；因此jal将PC+8写入返回寄存器$ra，才能保证函数返回后，正确执行延迟槽之后的指令。
3. 主要有三方面考虑：
- 功能部件（如ALU、DM）的输出通常在时钟周期**内部**的某个时间点才会稳定下来。在时钟周期内，功能部件的输出可能会随着输入的变化而变化，直到计算完成。这意味着，如果直接从功能部件获取数据，前递的数据可能在时钟周期内并不稳定，无法保证在需要使用的阶段提供正确的数据。**流水寄存器在时钟上升沿或下降沿采样输入数据**，并在**整个时钟周期内**保持**数据稳定**。
-  如果前递数据直接来自功能部件，需要对整个**组合逻辑**路径进行严格的**时序**分析，增加了设计和验证的复杂性。
- 便于模块化设计、复杂度降低和工程可扩展性。
4. 本质上就是取代W级向D级的转发。
5. 见上面的转发说明。
6. 首先分析该指令的 `Tuse` 和各级的 `Tnew` 。然后可以归结为以下几种类型：
   - R型计算指令，存在`rd`
   - I型计算指令，存在`rt` 
   - 条件跳转指令
   - 无条件跳转指令
   - `load` 类指令
   - `store` 类指令

然后M W两级分别向D E两级转发。特别地对于类似于`jal` 这样的无条件跳转指令，E级也需要向D级转发（往后每一级都要无脑转发PC）。
7. 采用分布式译码、控制信号驱动型
- 好处：较为灵活，降低了流水级间传递的信号量，每次译码出要用到的信号即可。

- 坏处：需要实例化多个控制器，增加了后续流水级的逻辑复杂度。如错添或漏添了某条指令，很难锁定出现错误的位置。 

## 新加信号
1. (清空延时槽)当阻塞信号 D_stall 开启时，跳过延迟槽信号 signal 必须关闭
```
assign E_isPCplus8 = (E_op == 6'b000011 || E_op = xxxxxx) ? 1'b1 : 1'b0;
assign M_isPCplus8 = (M_op == 6'b000011 || M_op = xxxxxx) ? 1'b1 : 1'b0;
```
```
// mips
//如果signal与op无关，则fixedsignal则需要与signal有关
wire fixedsignal;
assign fixedsignal = (signal & (~D_stall));
assign FD_clear = (fixedsignal) ? 1'b1 : 1'b0;
```
2. 与for循环相关(使用flag信号实现break)
```
reg [31:0] temp;
reg flag;
integer i;

always @(*) begin
    temp = 32'h00000020;
    flag = 1'b0;
    // 注意 Verilog 中没有 i-- 的语法！
    for (i = 31; i >= 0; i = i - 1) begin
        if (flag == 1'b0 && inputA[i] == 1'b0) begin
            temp = 31 - i;
            flag = 1'b1;
        end
    end
end
```
```
reg [6:0] temp1;
reg [6:0] temp2;

integer i;
integer flag1,flag2;
always @(*) begin
    flag1 = 0;
    flag2 = 0;
    temp1 = 0;
    temp2 = 0;
    for(i = 31;i >= 0; i = i - 1)begin
        if(A[i] == 1'b0 && flag1 ==0)begin
            temp1 = temp1 + 1'b1;
        end else begin
            flag1 = 1;
        end
        if(B[i] == 1'b1 && flag2 ==0)begin
            temp2 = temp2 + 1'b1;
        end else begin
            flag2 = 1;
        end
    end
end
```

## 测试
```
lui $s0, 0x0001      # $s0 = 00010000
lui $s1, 0x0010      # $s1 = 00100000
lui $s2, 0x0100      # $s2 = 01000000
lui $s3, 0x1000      # $s3 = 10000000
ori $s4, $0, 0x0001  # $s4 = 00000001
ori $s5, $0, 0x0010  # $s5 = 00000010
ori $s6, $0, 0x0100  # $s6 = 00000100 
ori $s7, $0, 0x1000  # $s7 = 00001000

ori $a0, $a0, 0x1234
sw $a0, 0($0)
ori $a1, $a1, 0xa5d7
sw $a1, 0x0100($0)
ori $a2, $a2, 0x9fd4
sw $a2, 8($0)
ori $a3, $a3, 0x4892
sw $a3, 0x0010($0)
sw $s6, 12($0)
sw $s7, 20($0)

# ---------- Stall ---------- #
# ----- rs_stall ----- #
# E_lw_rt and add_rs
lw $t0, 8($0)
lw $t0, 0($0)            # $t0 = 0x1234
add $t1, $t0, $s0	# $t1 = 0x11234

# E_lw_rt and sub_rs
lw $t2, 8($0)
lw $t2, 0($0)		# $t2 = 0x1234
sub $t1, $t2, $s1	# $t1 = fushu

# E_lw_rt and ori_rs
lw $t0, 12($0)
lw $t0, 8($0)		
ori $t1, $t0, 0x1234

# E_lw_rt and beq_rs
# M_lw_rt and beq_rs
lw $v0, 0($0)
beq $v0, $0, test_end
nop

# add_rd and beq_rs
add $v1, $s3, $s7 
add $v1, $s0, $s1
beq $v1, $0, test_end
nop

# sub_rd and beq_rs
sub $k0, $s3, $s5
sub $k0, $s0, $s4
beq $k0, $s0, test_end
nop

# ori_rt and beq_rt
ori $k1, $s6, 0x2983
ori $k1, $s2, 0x1234
beq $k1, $s2, test_end
nop

# E_lw_rt and lw_rs
lw $t3, 20($0)
lw $t3, 12($0)		# $t3 = 0x00000100
lw $t4, 0($t3)

# E_lw_rt and sw_rs
lw $t5, 12($0)
lw $t5, 20($0)
sw $s0, 0($t5)

# ori_rt and jr
ori $t0, $0, 0x30c8
jr $t0

# add_rt and jr
ori $t1, $0, 0x000c
add $t2, $t0, $t1
jr $t2

# E_lw_rt and jr
# M_lw_rt and jr
ori $t3, $0, 0x30e4
sw $t3, 0x2000($0)
lw $t4, 0x2000($0)
jr $t3


# ----- rt_stall ----- #
# E_lw_rt and add_rt
lw $t7, 12($0)
lw $t7, 0($0)
add $k0, $s3, $t7

# E_lw_rt and sub_rt
lw $t7, 20($0)
lw $t7, 4($0)
sub $k1, $s2, $t7

# E_lw_rt and beq_rt
# M_lw_rt and beq_rt
lw $t7, 0x2ffc($0)
beq $a1, $t7, test_end
nop

# E_add_rd and beq_rt
lui $t0, 0
add $t0, $0, $s0
beq $0, $t0, test_end
nop

# E_sub_rd and beq_rt
lui $t1, 0
sub $t1, $s1, $0
beq $0, $t1, test_end
nop

# E_ori_rt and beq_rt
lui $t0, 0
ori $t0, $0, 0x0010
beq $0, $t0, test_end
nop


# ---------- Transform ---------- #
# ----- D_for_rs ----- #
# D_for_rs <= E_PC + 8  add
lui $t0, 0
jal label1
add $t0, $ra, $0
label1:

# D_for_rs <= E_Imm32  sub
lui $t0, 0
lui $t0, 0x3984
sub $t1, $t0, $s6

# D_for_rs <= M_PC + 8  ori
lui $t0, 0
jal label2
nop
label2:
ori $t0, $ra, 0x2832

# D_for_rs <= M_Imm32  beq
lui $t0, 0x1000
lui $t0, 0x3903
nop
beq $t0, $s3, test_end
nop

# D_for_rs <= M_ALU_result  lw
lui $t0, 0
ori $t0, $t0, 0x0100
nop
lw $t1, 0($t0)

# D_for_rs <= W_PC + 8  add
jal label3
nop
label3:
nop
add $t7, $ra, $0

# D_for_rs <= W_Imm32  sub
lui $t0, 0x18e3
nop
nop
sub $t1, $t0, $s5

# D_for_rs <= W_ALU_result
add $t2, $t1, $t0
nop
nop
ori $t3, $t2, 0x3840

# D_for_rs <= W_RD
lw $t3, 12($0)
nop
nop
add $t4, $t3, $s3

# ----- D_for_rt ----- #
# D_for_rt <= E_PC + 8  add
lui $t0, 0
jal label4
add $t0, $0, $ra
label4:

# D_for_rt <= E_Imm32  sub
lui $t0, 0
lui $t0, 0x3984
sub $t1, $s6, $t0

# D_for_rt <= M_PC + 8  add
lui $t0, 0
jal label5
nop
label5:
add $t0, $s3, $t0

# D_for_rt <= M_Imm32  beq
lui $t0, 0x1000
lui $t0, 0x3903
nop
beq $s3, $t0, test_end
nop

# D_for_rt <= M_ALU_result  sw
lui $t0, 0
ori $t0, $t0, 0x0100
ori $t1, $0, 0x1093
nop
sw $t1, 32($t0)

# D_for_rt <= W_PC + 8  add
jal label6
nop
label6:
nop
add $t7, $0, $ra

# D_for_rs <= W_Imm32  sub
lui $t0, 0x88e3
nop
nop
sub $t1, $s5, $t0

# D_for_rs <= W_ALU_result
add $t2, $t1, $t0
nop
nop
add $t3, $s6, $t2

# D_for_rs <= W_RD
lw $t3, 12($0)
nop
nop
add $t4, $s3, $t3

# ----- E_for_rs ----- #
# E_for_rs <= M_ALU_result  lw
lui $t0, 0
ori $t0, $t0, 0x0100
lw $t1, 0($t0)

# E_for_rs <= W_RD
lw $t3, 12($0)
nop
add $t4, $t3, $s3

# ----- E_for_rt ----- #
# E_for_rt <= M_ALU_result  sw
ori $t0, $t0, 0x0100
ori $t1, $0, 0x1093
nop
sw $t1, 32($t0)

# E_for_rs <= W_RD
lw $t3, 12($0)
nop
nop
add $t4, $s3, $t3

# ----- M_for_rt ----- #
lw $t0, 0x0100($0)
nop
nop
sw $t0, 48($0)


# ---------- fake ---------- #
# ----- rs_stall ----- #
# E_lw_rt and add_rs
lw $0, 0($0)            # $t0 = 0x1234
add $t1, $0, $s0	# $t1 = 0x11234

# E_lw_rt and sub_rs
lw $0, 0x0100($0)		# $t2 = 0x1234
sub $t1, $0, $s1	# $t1 = fushu

# E_lw_rt and ori_rs
lw $0, 8($0)		
ori $t1, $t0, 0x1234

# E_lw_rt and beq_rs
# M_lw_rt and beq_rs
lw $0, 0($0)
beq $0, $a0, test_end
nop

# add_rd and beq_rs
add $0, $s0, $s1
beq $at, $0, next
nop
beq $0, $0, test_end
next:

# ori_rt and beq_rt
ori $0, $s2, 0x1234
beq $0, $s2, test_end
nop

# E_lw_rt and lw_rs
lw $0, 12($0)		# $t3 = 0x00000100
lw $t4, 0($0)

# E_lw_rt and sw_rs
lw $0, 20($0)
sw $s0, 0($0)

# ----- rt_stall ----- #
# E_lw_rt and add_rt
lw $0, 0($0)
add $k0, $s3, $0

# E_lw_rt and sub_rt
lw $0, 4($0)
sub $k1, $s2, $0

# E_lw_rt and beq_rt
# M_lw_rt and beq_rt
lw $0, 0x2ffc($0)
beq $a1, $0, test_end
nop

# E_add_rd and beq_rt
add $0, $0, $s0
beq $a0, $0, test_end
nop

# E_sub_rd and beq_rt
sub $0, $s1, $0
beq $a1, $0, test_end
nop

# E_ori_rt and beq_rt
ori $0 $t0, 0
beq $t0, $0, test_end
nop


# ---------- Transform ---------- #
# ----- D_for_rs ----- #
# D_for_rs <= E_Imm32  sub
lui $0, 0x3984
sub $t1, $0, $s6

# D_for_rs <= M_Imm32  beq
lui $0, 0x1000
nop
beq $0, $s3, test_end
nop

# D_for_rs <= M_ALU_result  lw
ori $0, $t0, 0x0100
nop
lw $t1, 0($0)

# D_for_rs <= W_Imm32  sub
lui $0, 0x18e3
nop
nop
sub $t1, $0, $s5

# D_for_rs <= W_ALU_result
add $0, $t1, $t0
nop
nop
ori $t3, $0, 0x3840

# D_for_rs <= W_RD
lw $0, 12($0)
nop
nop
add $t4, $0, $s3

# ----- D_for_rt ----- #
# D_for_rt <= E_Imm32  sub
lui $0, 0x3984
sub $t1, $s6, $0

# D_for_rt <= M_Imm32  beq
lui $0, 0x1000
nop
beq $s3, $0, test_end
nop

# D_for_rt <= M_ALU_result  sw
lui $t0, 0
ori $t0, $t0, 0x0100
nop
nop
nop
nop
nop
ori $0, $0, 0x1093
nop
sw $0, 32($t0)

# D_for_rs <= W_Imm32  sub
lui $0, 0x88e3
nop
nop
sub $t1, $s5, $0

# D_for_rs <= W_ALU_result
add $0, $t1, $t0
nop
nop
add $t3, $s6, $0

# D_for_rs <= W_RD
lw $0, 12($0)
nop
nop
add $t4, $s3, $0

# ----- E_for_rs ----- #
# E_for_rs <= M_ALU_result  lw
ori $0, $0, 0x0100
lw $t1, 0($0)

# E_for_rs <= W_RD
lw $0, 12($0)
nop
add $t4, $0, $s3

# ----- E_for_rt ----- #
# E_for_rt <= M_ALU_result  sw
ori $0, $0, 0x1093
nop
sw $0, 32($t0)

# E_for_rs <= W_RD
lw $0, 12($0)
nop
nop
add $t4, $s3, $0

# ----- M_for_rt ----- #
lw $0, 0x0100($0)
nop
nop
sw $0, 48($0)

test_end:
beq $0, $0, test_end
nop
```

```
3c100001
3c110010
3c120100
3c131000
34140001
34150010
34160100
34171000
34841234
ac040000
34a5a5d7
ac050100
34c69fd4
ac060008
34e74892
ac070010
ac16000c
ac170014
8c080008
8c080000
01104820
8c0a0008
8c0a0000
01514822
8c08000c
8c080008
35091234
8c020000
104000ef
00000000
02771820
02111820
106000eb
00000000
0275d022
0214d022
135000e7
00000000
36db2983
365b1234
137200e3
00000000
8c0b0014
8c0b000c
8d6c0000
8c0d000c
8c0d0014
adb00000
340830c8
01000008
3409000c
01095020
01400008
340b30e4
ac0b2000
8c0c2000
01600008
8c0f000c
8c0f0000
026fd020
8c0f0014
8c0f0004
024fd822
8c0f2ffc
10af00cb
00000000
3c080000
00104020
100800c7
00000000
3c090000
02204822
100900c3
00000000
3c080000
34080010
100800bf
00000000
3c080000
0c000c51
03e04020
3c080000
3c083984
01164822
3c080000
0c000c57
00000000
37e82832
3c081000
3c083903
00000000
111300b0
00000000
3c080000
35080100
00000000
8d090000
0c000c63
00000000
00000000
03e07820
3c0818e3
00000000
00000000
01154822
01285020
00000000
00000000
354b3840
8c0b000c
00000000
00000000
01736020
3c080000
0c000c74
001f4020
3c080000
3c083984
02c84822
3c080000
0c000c7a
00000000
02684020
3c081000
3c083903
00000000
1268008d
00000000
3c080000
35080100
34091093
00000000
ad090020
0c000c87
00000000
00000000
001f7820
3c0888e3
00000000
00000000
02a84822
01285020
00000000
00000000
02ca5820
8c0b000c
00000000
00000000
026b6020
3c080000
35080100
8d090000
8c0b000c
00000000
01736020
35080100
34091093
00000000
ad090020
8c0b000c
00000000
00000000
026b6020
8c080100
00000000
00000000
ac080030
8c000000
00104820
8c000100
00114822
8c000008
35091234
8c000000
1004005d
00000000
02110020
10200002
00000000
10000058
36401234
10120056
00000000
8c00000c
8c0c0000
8c000014
ac100000
8c000000
0260d020
8c000004
0240d822
8c002ffc
10a0004b
00000000
00100020
10800048
00000000
02200022
10a00045
00000000
35000000
11000042
00000000
3c003984
00164822
3c001000
00000000
1013003c
00000000
35000100
00000000
8c090000
3c0018e3
00000000
00000000
00154822
01280020
00000000
00000000
340b3840
8c00000c
00000000
00000000
00136020
3c003984
02c04822
3c001000
00000000
12600027
00000000
3c080000
35080100
00000000
00000000
00000000
00000000
00000000
34001093
00000000
ad000020
3c0088e3
00000000
00000000
02a04822
01280020
00000000
00000000
02c05820
8c00000c
00000000
00000000
02606020
34000100
8c090000
8c00000c
00000000
00136020
34001093
00000000
ad000020
8c00000c
00000000
00000000
02606020
8c000100
00000000
00000000
ac000030
1000ffff
00000000
```